{"name": "test_7[audit_feed_pass]", "status": "broken", "statusDetails": {"message": "urllib.error.URLError: <urlopen error [Errno 61] Connection refused>", "trace": "self = <urllib.request.HTTPHandler object at 0x1098f7da0>\nhttp_class = <class 'http.client.HTTPConnection'>\nreq = <urllib.request.Request object at 0x10b623358>, http_conn_args = {}\nhost = '192.168.1.175:8888'\nh = <http.client.HTTPConnection object at 0x10b7f3550>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10b7f3550>, method = 'POST'\nurl = '/graphql/?createThingInspection'\nbody = b'{\"query\": \"mutation createThingInspection($input: CreateThingInspectionInput!){\\\\n    createThingInspection(input: $...1}, \"things\": [{\"id\": 1}, {\"id\": 2}], \"period\": {\"type\": \"SINGLE\", \"startAt\": 1600243875487}}}, \"operationName\": null}'\nheaders = {'Accept': 'application/json; charset=utf-8', 'Authorization': 'Token eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJjcmVkZW5...V4cCI6MTYwMDMzMDE1MH0.eendcjGT83AZxHbxXnopXSaNNLtK8RvS8qPfjjfpXp8', 'Connection': 'close', 'Content-Length': 6613, ...}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10b7f3550>, method = 'POST'\nurl = '/graphql/?createThingInspection'\nbody = b'{\"query\": \"mutation createThingInspection($input: CreateThingInspectionInput!){\\\\n    createThingInspection(input: $...1}, \"things\": [{\"id\": 1}, {\"id\": 2}], \"period\": {\"type\": \"SINGLE\", \"startAt\": 1600243875487}}}, \"operationName\": null}'\nheaders = {'Accept': 'application/json; charset=utf-8', 'Authorization': 'Token eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJjcmVkZW5...V4cCI6MTYwMDMzMDE1MH0.eendcjGT83AZxHbxXnopXSaNNLtK8RvS8qPfjjfpXp8', 'Connection': 'close', 'Content-Length': 6613, ...}\nencode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10b7f3550>\nmessage_body = b'{\"query\": \"mutation createThingInspection($input: CreateThingInspectionInput!){\\\\n    createThingInspection(input: $...1}, \"things\": [{\"id\": 1}, {\"id\": 2}], \"period\": {\"type\": \"SINGLE\", \"startAt\": 1600243875487}}}, \"operationName\": null}'\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10b7f3550>\nmessage_body = b'{\"query\": \"mutation createThingInspection($input: CreateThingInspectionInput!){\\\\n    createThingInspection(input: $...1}, \"things\": [{\"id\": 1}, {\"id\": 2}], \"period\": {\"type\": \"SINGLE\", \"startAt\": 1600243875487}}}, \"operationName\": null}'\nencode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10b7f3550>\ndata = b'POST /graphql/?createThingInspection HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.175:8888\\r\\nUser-Agent...SaNNLtK8RvS8qPfjjfpXp8\\r\\nAccept: application/json; charset=utf-8\\r\\nContent-Length: 6613\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10b7f3550>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.175', 8888), timeout = None, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/socket.py:722: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.175', 8888), timeout = None, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 61] Connection refused\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <interface.workFlow_test.test_thingInspectionFlow.TestThingInspectionWorkFlow object at 0x10b623b38>\naction = 'audit_feed_pass'\n\n    @pytest.mark.parametrize(\"action\", test_data)\n    @allure.story(\"巡检完成不允许的操作\")\n    def test_7(self, action):\n>       thing_inspection_id = self.simple_user.create_thing_inspection()\n\ntest_thingInspectionFlow.py:227: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntest_thingInspectionFlow.py:36: in create_thing_inspection\n    thing_inspection_id = self.user(query_name, variables).find_result(\"$..id\")[0]\n../../support/data_maker/GraphqlClient.py:83: in __call__\n    self.send_request(query, variables)\n../../support/data_maker/GraphqlClient.py:37: in send_request\n    result = self.graphql_client(query, variables)\n../../venv/lib/python3.6/site-packages/sgqlc/endpoint/http.py:150: in __call__\n    with self.urlopen(req, timeout=timeout or self.timeout) as f:\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x1098f7da0>\nhttp_class = <class 'http.client.HTTPConnection'>\nreq = <urllib.request.Request object at 0x10b623358>, http_conn_args = {}\nhost = '192.168.1.175:8888'\nh = <http.client.HTTPConnection object at 0x10b7f3550>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 61] Connection refused>\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/urllib/request.py:1320: URLError"}, "attachments": [{"name": "log", "source": "8cb07edb-e80c-4748-9520-c15ae37ea954-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "action", "value": "'audit_feed_pass'"}], "start": 1600243875487, "stop": 1600243875510, "uuid": "e255be95-2bfe-4dd1-9413-2eab09de6bdb", "historyId": "fbfc699db971291c506d73b2f21ddd88", "testCaseId": "6643c6f76d9d3af61d4181d381acf4b3", "fullName": "interface.workFlow_test.test_thingInspectionFlow.TestThingInspectionWorkFlow#test_7", "labels": [{"name": "epic", "value": "workflow"}, {"name": "feature", "value": "ThingInspectionWorkFlow"}, {"name": "story", "value": "巡检完成不允许的操作"}, {"name": "parentSuite", "value": "interface.workFlow_test"}, {"name": "suite", "value": "test_thingInspectionFlow"}, {"name": "subSuite", "value": "TestThingInspectionWorkFlow"}, {"name": "host", "value": "MacBook-Pro.local"}, {"name": "thread", "value": "5049-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "interface.workFlow_test.test_thingInspectionFlow"}]}